/**
 * F.A.I.L. Kit LangChain Adapter (JavaScript/TypeScript)
 * 
 * Drop-in adapter for integrating LangChain.js agents with the F.A.I.L. Kit audit framework.
 * Automatically generates receipts from LangChain tool executions.
 */

import { Router, Request, Response } from 'express';
import { Tool, StructuredTool } from '@langchain/core/tools';
import { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';
import crypto from 'crypto';

// Type for AgentExecutor to avoid direct import dependency
interface AgentExecutorLike {
  invoke: (input: any) => Promise<any>;
  tools: any[];
}

/**
 * Configuration for F.A.I.L. Kit LangChain adapter
 */
export interface FailKitConfig {
  autoReceipts?: boolean;
  includeMetadata?: boolean;
  trackLatency?: boolean;
  hashAlgorithm?: string;
}

/**
 * Standard F.A.I.L. Kit request format
 */
export interface FailKitRequest {
  prompt?: string;
  inputs?: {
    user?: string;
    [key: string]: any;
  };
  context?: Record<string, any>;
}

/**
 * Action receipt compliant with RECEIPT_SCHEMA.json
 */
export interface ActionReceipt {
  action_id: string;
  tool_name: string;
  timestamp: string;
  status: 'success' | 'failed';
  input_hash: string;
  output_hash: string;
  trace_id?: string;
  latency_ms?: number;
  error_message?: string;
  metadata?: Record<string, any>;
}

/**
 * F.A.I.L. Kit response format
 */
export interface FailKitResponse {
  outputs: {
    final_text: string;
    decision: string;
  };
  actions: ActionReceipt[];
  policy: {
    refuse: boolean;
    abstain: boolean;
    escalate: boolean;
    reasons: string[];
  };
}

/**
 * Generate hash for receipt verification
 * 
 * @param data - Data to hash (will be JSON serialized)
 * @param algorithm - Hash algorithm (default: sha256)
 * @returns Hash string in format "algorithm:hexdigest"
 */
export function hashData(data: any, algorithm: string = 'sha256'): string {
  const serialized = JSON.stringify(data, Object.keys(data).sort());
  const hash = crypto.createHash(algorithm).update(serialized).digest('hex');
  return `${algorithm}:${hash}`;
}

/**
 * Base class for LangChain.js tools that automatically generate receipts.
 * 
 * Extend this class and implement _execute() instead of _call().
 * Receipts are automatically generated and stored.
 * 
 * @example
 * ```typescript
 * class EmailTool extends ReceiptGeneratingTool {
 *   name = 'email_sender';
 *   description = 'Send an email';
 *   
 *   async _execute(input: { to: string; subject: string; body: string }) {
 *     await sendEmail(input.to, input.subject, input.body);
 *     return { status: 'sent', message_id: 'msg_123' };
 *   }
 * }
 * ```
 */
export abstract class ReceiptGeneratingTool extends Tool {
  private _receipts: ActionReceipt[] = [];
  
  /**
   * Execute tool and generate receipt.
   * DO NOT OVERRIDE - implement _execute() instead.
   */
  async _call(
    input: string,
    _runManager?: CallbackManagerForToolRun
  ): Promise<string> {
    const actionId = `act_${crypto.randomBytes(4).toString('hex')}`;
    const startTime = Date.now();
    
    // Parse input if string
    let parsedInput: any = input;
    try {
      parsedInput = JSON.parse(input);
    } catch {
      parsedInput = { input };
    }
    
    let outputData: any;
    let status: 'success' | 'failed' = 'success';
    let errorMessage: string | undefined;
    
    try {
      // Execute the tool
      outputData = await this._execute(parsedInput);
    } catch (error: any) {
      outputData = { error: error.message };
      status = 'failed';
      errorMessage = error.message;
    }
    
    const latencyMs = Date.now() - startTime;
    
    // Generate receipt compliant with RECEIPT_SCHEMA.json
    const receipt: ActionReceipt = {
      action_id: actionId,
      tool_name: this.name,
      timestamp: new Date().toISOString(),
      status,
      input_hash: hashData(parsedInput),
      output_hash: hashData(outputData),
      latency_ms: latencyMs
    };
    
    if (errorMessage) {
      receipt.error_message = errorMessage;
    }
    
    // Add custom metadata if returned by tool
    if (outputData && typeof outputData === 'object' && 'metadata' in outputData) {
      receipt.metadata = outputData.metadata;
    }
    
    // Store receipt for later retrieval
    this._receipts.push(receipt);
    
    if (status === 'failed') {
      throw new Error(errorMessage);
    }
    
    // Return as string for LangChain
    return typeof outputData === 'string' ? outputData : JSON.stringify(outputData);
  }
  
  /**
   * Override this method with your tool logic.
   * 
   * @param input - Tool-specific input
   * @returns Tool output (object recommended for structured data)
   * @throws Error on tool failure
   */
  abstract _execute(input: any): Promise<any>;
  
  /**
   * Get all receipts generated by this tool
   */
  getReceipts(): ActionReceipt[] {
    return [...this._receipts];
  }
  
  /**
   * Clear stored receipts
   */
  clearReceipts(): void {
    this._receipts = [];
  }
}

/**
 * Extract action receipts from AgentExecutor intermediate steps.
 * 
 * @param agentExecutor - The AgentExecutor instance
 * @param result - Result from agentExecutor.call()
 * @param config - Optional configuration
 * @returns Array of action receipts compliant with RECEIPT_SCHEMA.json
 */
export function extractReceiptsFromAgentExecutor(
  agentExecutor: AgentExecutorLike,
  result: any,
  config?: FailKitConfig
): ActionReceipt[] {
  const cfg = config || {};
  const receipts: ActionReceipt[] = [];
  
  // Extract from intermediate steps
  const intermediateSteps = result.intermediateSteps || [];
  
  for (let i = 0; i < intermediateSteps.length; i++) {
    const step = intermediateSteps[i];
    const action = step.action;
    const observation = step.observation;
    
    const actionId = `act_${crypto.randomBytes(4).toString('hex')}`;
    
    // Extract tool info
    const toolName = action?.tool || `unknown_tool_${i}`;
    const toolInput = action?.toolInput || {};
    
    // Prepare receipt
    const receipt: ActionReceipt = {
      action_id: actionId,
      tool_name: toolName,
      timestamp: new Date().toISOString(),
      status: observation ? 'success' : 'failed',
      input_hash: hashData(toolInput, cfg.hashAlgorithm || 'sha256'),
      output_hash: hashData({ result: observation }, cfg.hashAlgorithm || 'sha256')
    };
    
    if (cfg.includeMetadata) {
      receipt.metadata = {
        observation: String(observation).substring(0, 200),
        log: action?.log?.substring(0, 200) || ''
      };
    }
    
    receipts.push(receipt);
  }
  
  // Also collect from ReceiptGeneratingTool instances
  for (const tool of agentExecutor.tools) {
    if (tool instanceof ReceiptGeneratingTool) {
      const toolReceipts = tool.getReceipts();
      receipts.push(...toolReceipts);
      tool.clearReceipts(); // Clear for next invocation
    }
  }
  
  return receipts;
}

/**
 * Wrap a legacy LangChain tool to generate receipts.
 * 
 * @param tool - Existing Tool instance
 * @returns ReceiptGeneratingTool that wraps the original tool
 */
export function wrapToolWithReceipts(tool: Tool): ReceiptGeneratingTool {
  class WrappedTool extends ReceiptGeneratingTool {
    name = tool.name;
    description = tool.description;
    
    async _execute(input: any): Promise<any> {
      // Use invoke which is the public API
      return await tool.invoke(typeof input === 'string' ? input : JSON.stringify(input));
    }
  }
  
  return new WrappedTool();
}

/**
 * Create an Express router with the /run endpoint for F.A.I.L. Kit audits.
 * 
 * @param agentExecutor - LangChain AgentExecutor instance
 * @param config - Optional FailKitConfig
 * @param customHandler - Optional custom handler function
 * @returns Express Router with POST /run endpoint
 * 
 * @example
 * ```typescript
 * const app = express();
 * app.use('/eval', createFailKitRouter(agentExecutor));
 * ```
 */
export function createFailKitRouter(
  agentExecutor: AgentExecutorLike,
  config?: FailKitConfig,
  customHandler?: (executor: AgentExecutorLike, prompt: string, context: any) => Promise<any>
): Router {
  const cfg = config || {};
  const router = Router();
  
  router.use((req, res, next) => {
    if (!req.body) {
      return res.status(400).json({ error: 'Request body required' });
    }
    next();
  });
  
  router.post('/run', async (req: Request, res: Response) => {
    try {
      const body = req.body as FailKitRequest;
      
      // Extract prompt from request
      let prompt = body.prompt;
      if (!prompt && body.inputs) {
        prompt = body.inputs.user || '';
      }
      
      if (!prompt) {
        return res.status(400).json({ error: 'Missing prompt or inputs.user' });
      }
      
      // Run agent with custom handler if provided
      let result: any;
      if (customHandler) {
        result = await customHandler(agentExecutor, prompt, body.context || {});
      } else {
        // Use invoke (modern LangChain API)
        result = await agentExecutor.invoke({ input: prompt });
      }
      
      // Extract output text
      let outputText = result.output || result.result || result.response || '';
      
      // Extract receipts
      const receipts = extractReceiptsFromAgentExecutor(
        agentExecutor,
        result,
        cfg
      );
      
      // Build response in F.A.I.L. Kit format
      const response: FailKitResponse = {
        outputs: {
          final_text: outputText,
          decision: 'PASS'
        },
        actions: receipts,
        policy: {
          refuse: false,
          abstain: false,
          escalate: false,
          reasons: []
        }
      };
      
      // Check if we should escalate based on action failures
      const failedActions = receipts.filter(r => r.status === 'failed');
      if (failedActions.length > 0) {
        response.policy.escalate = true;
        response.policy.reasons.push('tool_failure');
        response.outputs.decision = 'FAIL';
      }
      
      res.json(response);
    } catch (error: any) {
      console.error('F.A.I.L. Kit handler error:', error);
      res.status(500).json({
        error: error.message || 'Internal server error',
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    }
  });
  
  return router;
}

/**
 * Simple wrapper for agents that don't track actions.
 * Automatically instruments the response to extract claimed actions.
 * 
 * @param agentFunction - Function that processes prompts
 * @returns Express Router
 */
export function createSimpleFailKitRouter(
  agentFunction: (prompt: string, context: any) => Promise<string | FailKitResponse>
): Router {
  const router = Router();
  
  router.post('/run', async (req: Request, res: Response) => {
    try {
      const body = req.body as FailKitRequest;
      const prompt = body.prompt || body.inputs?.user || '';
      
      if (!prompt) {
        return res.status(400).json({ error: 'Missing prompt' });
      }
      
      const result = await agentFunction(prompt, body.context || {});
      
      // If result is a string, wrap it
      if (typeof result === 'string') {
        res.json({
          outputs: {
            final_text: result,
            decision: 'PASS'
          },
          actions: [],
          policy: {
            refuse: false,
            abstain: false,
            escalate: false,
            reasons: []
          }
        });
      } else {
        // Result is already formatted
        res.json(result);
      }
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });
  
  return router;
}

// ============================================
// NEW v1.6.0: Compliance Mappings
// ============================================

export interface ComplianceMapping {
  soc2?: string[];
  pciDss?: string[];
  hipaa?: string[];
  gdpr?: string[];
  iso27001?: string[];
}

export const COMPLIANCE_MAPPINGS: Record<string, ComplianceMapping> = {
  FK001: {
    soc2: ['CC6.1', 'CC7.2', 'CC7.3'],
    pciDss: ['10.2.2', '10.3', '10.3.1'],
    hipaa: ['164.312(b)', '164.308(a)(1)(ii)(D)'],
    gdpr: ['Art. 30', 'Art. 5(2)'],
  },
  FK002: {
    soc2: ['CC7.4', 'CC7.5'],
    pciDss: ['6.5.5', '6.5.6'],
    hipaa: ['164.308(a)(1)', '164.306(a)(2)'],
  },
  FK003: {
    soc2: ['CC6.7', 'CC6.8', 'CC6.1'],
    pciDss: ['3.4', '6.5.3', '8.2.1'],
    hipaa: ['164.312(a)(1)', '164.312(e)(1)'],
    gdpr: ['Art. 32', 'Art. 25'],
  },
  FK004: {
    soc2: ['CC6.1', 'CC7.1', 'CC7.2'],
    pciDss: ['7.1', '7.2', '10.2.5'],
    hipaa: ['164.312(d)', '164.308(a)(4)'],
  },
  FK005: {
    soc2: ['A1.2', 'CC7.4'],
    pciDss: ['6.5.6', '12.10.1'],
  },
  FK006: {
    soc2: ['CC5.2', 'CC7.2', 'CC7.3'],
    pciDss: ['10.1', '10.2', '10.3.6'],
    hipaa: ['164.312(b)', '164.308(a)(1)(ii)(D)'],
    gdpr: ['Art. 30', 'Art. 5(2)'],
  },
  FK007: {
    soc2: ['CC6.7', 'CC6.8'],
    pciDss: ['2.3', '8.2.1', '8.2.3'],
    hipaa: ['164.312(a)(1)', '164.312(d)'],
    gdpr: ['Art. 32'],
  },
};

/**
 * Get compliance badges for a rule
 */
export function getComplianceBadges(ruleId: string): string[] {
  const mapping = COMPLIANCE_MAPPINGS[ruleId];
  if (!mapping) return [];
  
  const badges: string[] = [];
  if (mapping.soc2?.length) badges.push('SOC2');
  if (mapping.pciDss?.length) badges.push('PCI-DSS');
  if (mapping.hipaa?.length) badges.push('HIPAA');
  if (mapping.gdpr?.length) badges.push('GDPR');
  if (mapping.iso27001?.length) badges.push('ISO27001');
  
  return badges;
}

// ============================================
// NEW v1.6.0: Resilience Utilities
// ============================================

export interface RetryConfig {
  maxRetries?: number;
  baseDelay?: number;
  maxDelay?: number;
  exponentialBase?: number;
  jitter?: boolean;
  onRetry?: (error: Error, attempt: number) => void;
}

/**
 * Execute a function with retry logic
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig = {}
): Promise<T> {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 30000,
    exponentialBase = 2,
    jitter = true,
    onRetry,
  } = config;

  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      lastError = error;
      
      if (attempt < maxRetries) {
        let delay = Math.min(baseDelay * Math.pow(exponentialBase, attempt), maxDelay);
        
        if (jitter) {
          delay *= 0.5 + Math.random();
        }
        
        if (onRetry) {
          onRetry(error, attempt + 1);
        }
        
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}

/**
 * Execute a function with timeout
 */
export async function withTimeout<T>(
  fn: () => Promise<T>,
  timeoutMs: number
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`Operation timed out after ${timeoutMs}ms`));
    }, timeoutMs);

    fn()
      .then(result => {
        clearTimeout(timer);
        resolve(result);
      })
      .catch(error => {
        clearTimeout(timer);
        reject(error);
      });
  });
}

// ============================================
// NEW v1.6.0: Evidence Generation
// ============================================

export interface EvidencePackage {
  version: string;
  generatedAt: string;
  receipts: ActionReceipt[];
  provenance: ProvenanceData;
  signature: string;
  signatureAlgorithm: string;
  complianceMappings: Record<string, string[]>;
}

export interface ProvenanceData {
  gitHash?: string;
  gitBranch?: string;
  platform?: string;
  nodeVersion?: string;
  failKitVersion: string;
}

/**
 * Generate HMAC signature for evidence integrity
 */
function signEvidence(data: string): string {
  return crypto.createHmac('sha256', 'fail-kit-evidence').update(data).digest('hex');
}

/**
 * Generate an evidence package for audit export
 */
export function generateEvidencePackage(
  receipts: ActionReceipt[],
  provenance: Partial<ProvenanceData> = {}
): EvidencePackage {
  const fullProvenance: ProvenanceData = {
    failKitVersion: '1.6.0',
    platform: process.platform,
    nodeVersion: process.version,
    ...provenance,
  };

  const dataToSign = JSON.stringify(receipts);

  // Map receipts to compliance frameworks
  const complianceMappings: Record<string, string[]> = {};
  for (const receipt of receipts) {
    const toolName = receipt.tool_name.toLowerCase();
    if (toolName.includes('payment') || toolName.includes('charge')) {
      complianceMappings['PCI-DSS'] = COMPLIANCE_MAPPINGS.FK001.pciDss || [];
    }
    if (toolName.includes('database') || toolName.includes('user')) {
      complianceMappings['HIPAA'] = COMPLIANCE_MAPPINGS.FK001.hipaa || [];
    }
  }

  return {
    version: '1.0.0',
    generatedAt: new Date().toISOString(),
    receipts,
    provenance: fullProvenance,
    signature: signEvidence(dataToSign),
    signatureAlgorithm: 'HMAC-SHA256',
    complianceMappings,
  };
}

/**
 * Export evidence as CSV
 */
export function exportEvidenceAsCSV(receipts: ActionReceipt[]): string {
  const headers = ['action_id', 'tool_name', 'timestamp', 'status', 'input_hash', 'output_hash', 'latency_ms'];
  const rows = receipts.map(r => 
    headers.map(h => String((r as any)[h] || '')).join(',')
  );
  return [headers.join(','), ...rows].join('\n');
}

// ============================================
// NEW v1.6.0: Secret Detection
// ============================================

interface SecretFinding {
  type: string;
  masked: string;
  severity: 'critical' | 'high' | 'medium';
}

const SECRET_PATTERNS: Array<{ pattern: RegExp; type: string }> = [
  { pattern: /sk[-_]live[-_][a-zA-Z0-9]{20,}/g, type: 'stripe_secret_key' },
  { pattern: /sk[-_]test[-_][a-zA-Z0-9]{20,}/g, type: 'stripe_test_key' },
  { pattern: /AKIA[A-Z0-9]{16}/g, type: 'aws_access_key' },
  { pattern: /sk-[a-zA-Z0-9]{32,}/g, type: 'openai_api_key' },
  { pattern: /ghp_[a-zA-Z0-9]{36}/g, type: 'github_pat' },
];

/**
 * Detect potential secrets in text
 */
export function detectSecrets(text: string): SecretFinding[] {
  const findings: SecretFinding[] = [];
  
  for (const { pattern, type } of SECRET_PATTERNS) {
    pattern.lastIndex = 0;
    let match: RegExpExecArray | null;
    while ((match = pattern.exec(text)) !== null) {
      const value = match[0];
      findings.push({
        type,
        masked: value.length > 8 ? `${value.slice(0, 4)}...${value.slice(-4)}` : '***',
        severity: 'critical',
      });
    }
  }
  
  return findings;
}
