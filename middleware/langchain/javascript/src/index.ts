/**
 * F.A.I.L. Kit LangChain Adapter (JavaScript/TypeScript)
 * 
 * Drop-in adapter for integrating LangChain.js agents with the F.A.I.L. Kit audit framework.
 * Automatically generates receipts from LangChain tool executions.
 */

import { Router, Request, Response } from 'express';
import { AgentExecutor } from 'langchain/agents';
import { Tool, StructuredTool } from '@langchain/core/tools';
import { AgentAction, AgentFinish } from '@langchain/core/agents';
import crypto from 'crypto';

/**
 * Configuration for F.A.I.L. Kit LangChain adapter
 */
export interface FailKitConfig {
  autoReceipts?: boolean;
  includeMetadata?: boolean;
  trackLatency?: boolean;
  hashAlgorithm?: string;
}

/**
 * Standard F.A.I.L. Kit request format
 */
export interface FailKitRequest {
  prompt?: string;
  inputs?: {
    user?: string;
    [key: string]: any;
  };
  context?: Record<string, any>;
}

/**
 * Action receipt compliant with RECEIPT_SCHEMA.json
 */
export interface ActionReceipt {
  action_id: string;
  tool_name: string;
  timestamp: string;
  status: 'success' | 'failed';
  input_hash: string;
  output_hash: string;
  trace_id?: string;
  latency_ms?: number;
  error_message?: string;
  metadata?: Record<string, any>;
}

/**
 * F.A.I.L. Kit response format
 */
export interface FailKitResponse {
  outputs: {
    final_text: string;
    decision: string;
  };
  actions: ActionReceipt[];
  policy: {
    refuse: boolean;
    abstain: boolean;
    escalate: boolean;
    reasons: string[];
  };
}

/**
 * Generate hash for receipt verification
 * 
 * @param data - Data to hash (will be JSON serialized)
 * @param algorithm - Hash algorithm (default: sha256)
 * @returns Hash string in format "algorithm:hexdigest"
 */
export function hashData(data: any, algorithm: string = 'sha256'): string {
  const serialized = JSON.stringify(data, Object.keys(data).sort());
  const hash = crypto.createHash(algorithm).update(serialized).digest('hex');
  return `${algorithm}:${hash}`;
}

/**
 * Base class for LangChain.js tools that automatically generate receipts.
 * 
 * Extend this class and implement _execute() instead of _call().
 * Receipts are automatically generated and stored.
 * 
 * @example
 * ```typescript
 * class EmailTool extends ReceiptGeneratingTool {
 *   name = 'email_sender';
 *   description = 'Send an email';
 *   
 *   async _execute(input: { to: string; subject: string; body: string }) {
 *     await sendEmail(input.to, input.subject, input.body);
 *     return { status: 'sent', message_id: 'msg_123' };
 *   }
 * }
 * ```
 */
export abstract class ReceiptGeneratingTool extends Tool {
  private _receipts: ActionReceipt[] = [];
  
  /**
   * Execute tool and generate receipt.
   * DO NOT OVERRIDE - implement _execute() instead.
   */
  async _call(input: string | Record<string, any>): Promise<any> {
    const actionId = `act_${crypto.randomBytes(4).toString('hex')}`;
    const startTime = Date.now();
    
    // Parse input if string
    let parsedInput = input;
    if (typeof input === 'string') {
      try {
        parsedInput = JSON.parse(input);
      } catch {
        parsedInput = { input };
      }
    }
    
    let outputData: any;
    let status: 'success' | 'failed' = 'success';
    let errorMessage: string | undefined;
    
    try {
      // Execute the tool
      outputData = await this._execute(parsedInput);
    } catch (error: any) {
      outputData = { error: error.message };
      status = 'failed';
      errorMessage = error.message;
    }
    
    const latencyMs = Date.now() - startTime;
    
    // Generate receipt compliant with RECEIPT_SCHEMA.json
    const receipt: ActionReceipt = {
      action_id: actionId,
      tool_name: this.name,
      timestamp: new Date().toISOString(),
      status,
      input_hash: hashData(parsedInput),
      output_hash: hashData(outputData),
      latency_ms: latencyMs
    };
    
    if (errorMessage) {
      receipt.error_message = errorMessage;
    }
    
    // Add custom metadata if returned by tool
    if (outputData && typeof outputData === 'object' && 'metadata' in outputData) {
      receipt.metadata = outputData.metadata;
    }
    
    // Store receipt for later retrieval
    this._receipts.push(receipt);
    
    if (status === 'failed') {
      throw new Error(errorMessage);
    }
    
    return outputData;
  }
  
  /**
   * Override this method with your tool logic.
   * 
   * @param input - Tool-specific input
   * @returns Tool output (object recommended for structured data)
   * @throws Error on tool failure
   */
  abstract _execute(input: any): Promise<any>;
  
  /**
   * Get all receipts generated by this tool
   */
  getReceipts(): ActionReceipt[] {
    return [...this._receipts];
  }
  
  /**
   * Clear stored receipts
   */
  clearReceipts(): void {
    this._receipts = [];
  }
}

/**
 * Extract action receipts from AgentExecutor intermediate steps.
 * 
 * @param agentExecutor - The AgentExecutor instance
 * @param result - Result from agentExecutor.call()
 * @param config - Optional configuration
 * @returns Array of action receipts compliant with RECEIPT_SCHEMA.json
 */
export function extractReceiptsFromAgentExecutor(
  agentExecutor: AgentExecutor,
  result: any,
  config?: FailKitConfig
): ActionReceipt[] {
  const cfg = config || {};
  const receipts: ActionReceipt[] = [];
  
  // Extract from intermediate steps
  const intermediateSteps = result.intermediateSteps || [];
  
  for (let i = 0; i < intermediateSteps.length; i++) {
    const step = intermediateSteps[i];
    const action = step.action;
    const observation = step.observation;
    
    const actionId = `act_${crypto.randomBytes(4).toString('hex')}`;
    
    // Extract tool info
    const toolName = action?.tool || `unknown_tool_${i}`;
    const toolInput = action?.toolInput || {};
    
    // Prepare receipt
    const receipt: ActionReceipt = {
      action_id: actionId,
      tool_name: toolName,
      timestamp: new Date().toISOString(),
      status: observation ? 'success' : 'failed',
      input_hash: hashData(toolInput, cfg.hashAlgorithm || 'sha256'),
      output_hash: hashData({ result: observation }, cfg.hashAlgorithm || 'sha256')
    };
    
    if (cfg.includeMetadata) {
      receipt.metadata = {
        observation: String(observation).substring(0, 200),
        log: action?.log?.substring(0, 200) || ''
      };
    }
    
    receipts.push(receipt);
  }
  
  // Also collect from ReceiptGeneratingTool instances
  for (const tool of agentExecutor.tools) {
    if (tool instanceof ReceiptGeneratingTool) {
      const toolReceipts = tool.getReceipts();
      receipts.push(...toolReceipts);
      tool.clearReceipts(); // Clear for next invocation
    }
  }
  
  return receipts;
}

/**
 * Wrap a legacy LangChain tool to generate receipts.
 * 
 * @param tool - Existing Tool instance
 * @returns ReceiptGeneratingTool that wraps the original tool
 */
export function wrapToolWithReceipts(tool: Tool): ReceiptGeneratingTool {
  class WrappedTool extends ReceiptGeneratingTool {
    name = tool.name;
    description = tool.description;
    
    async _execute(input: any): Promise<any> {
      return await tool._call(input);
    }
  }
  
  return new WrappedTool();
}

/**
 * Create an Express router with the /run endpoint for F.A.I.L. Kit audits.
 * 
 * @param agentExecutor - LangChain AgentExecutor instance
 * @param config - Optional FailKitConfig
 * @param customHandler - Optional custom handler function
 * @returns Express Router with POST /run endpoint
 * 
 * @example
 * ```typescript
 * const app = express();
 * app.use('/eval', createFailKitRouter(agentExecutor));
 * ```
 */
export function createFailKitRouter(
  agentExecutor: AgentExecutor,
  config?: FailKitConfig,
  customHandler?: (executor: AgentExecutor, prompt: string, context: any) => Promise<any>
): Router {
  const cfg = config || {};
  const router = Router();
  
  router.use((req, res, next) => {
    if (!req.body) {
      return res.status(400).json({ error: 'Request body required' });
    }
    next();
  });
  
  router.post('/run', async (req: Request, res: Response) => {
    try {
      const body = req.body as FailKitRequest;
      
      // Extract prompt from request
      let prompt = body.prompt;
      if (!prompt && body.inputs) {
        prompt = body.inputs.user || '';
      }
      
      if (!prompt) {
        return res.status(400).json({ error: 'Missing prompt or inputs.user' });
      }
      
      // Run agent with custom handler if provided
      let result: any;
      if (customHandler) {
        result = await customHandler(agentExecutor, prompt, body.context || {});
      } else {
        // Ensure intermediate steps are returned
        result = await agentExecutor.call(
          { input: prompt },
          { returnIntermediateSteps: true }
        );
      }
      
      // Extract output text
      let outputText = result.output || result.result || result.response || '';
      
      // Extract receipts
      const receipts = extractReceiptsFromAgentExecutor(
        agentExecutor,
        result,
        cfg
      );
      
      // Build response in F.A.I.L. Kit format
      const response: FailKitResponse = {
        outputs: {
          final_text: outputText,
          decision: 'PASS'
        },
        actions: receipts,
        policy: {
          refuse: false,
          abstain: false,
          escalate: false,
          reasons: []
        }
      };
      
      // Check if we should escalate based on action failures
      const failedActions = receipts.filter(r => r.status === 'failed');
      if (failedActions.length > 0) {
        response.policy.escalate = true;
        response.policy.reasons.push('tool_failure');
        response.outputs.decision = 'FAIL';
      }
      
      res.json(response);
    } catch (error: any) {
      console.error('F.A.I.L. Kit handler error:', error);
      res.status(500).json({
        error: error.message || 'Internal server error',
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    }
  });
  
  return router;
}

/**
 * Simple wrapper for agents that don't track actions.
 * Automatically instruments the response to extract claimed actions.
 * 
 * @param agentFunction - Function that processes prompts
 * @returns Express Router
 */
export function createSimpleFailKitRouter(
  agentFunction: (prompt: string, context: any) => Promise<string | FailKitResponse>
): Router {
  const router = Router();
  
  router.post('/run', async (req: Request, res: Response) => {
    try {
      const body = req.body as FailKitRequest;
      const prompt = body.prompt || body.inputs?.user || '';
      
      if (!prompt) {
        return res.status(400).json({ error: 'Missing prompt' });
      }
      
      const result = await agentFunction(prompt, body.context || {});
      
      // If result is a string, wrap it
      if (typeof result === 'string') {
        res.json({
          outputs: {
            final_text: result,
            decision: 'PASS'
          },
          actions: [],
          policy: {
            refuse: false,
            abstain: false,
            escalate: false,
            reasons: []
          }
        });
      } else {
        // Result is already formatted
        res.json(result);
      }
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });
  
  return router;
}
