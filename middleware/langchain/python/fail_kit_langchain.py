"""
F.A.I.L. Kit LangChain Adapter (Python)

Drop-in adapter for integrating LangChain agents with the F.A.I.L. Kit audit framework.
Automatically generates receipts from LangChain tool executions.
"""

import hashlib
import json
import time
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional, Union, Callable

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from langchain.agents import AgentExecutor
from langchain.tools import BaseTool
from langchain_core.agents import AgentAction, AgentFinish


class FailKitRequest(BaseModel):
    """Standard F.A.I.L. Kit request format"""
    prompt: Optional[str] = None
    inputs: Optional[Dict[str, Any]] = None
    context: Optional[Dict[str, Any]] = None


class FailKitConfig:
    """Configuration for F.A.I.L. Kit LangChain adapter"""
    
    def __init__(
        self,
        auto_receipts: bool = True,
        include_metadata: bool = True,
        track_latency: bool = True,
        hash_algorithm: str = "sha256"
    ):
        self.auto_receipts = auto_receipts
        self.include_metadata = include_metadata
        self.track_latency = track_latency
        self.hash_algorithm = hash_algorithm


def hash_data(data: Any, algorithm: str = "sha256") -> str:
    """
    Generate hash for receipt verification
    
    Args:
        data: Data to hash (will be JSON serialized)
        algorithm: Hash algorithm (default: sha256)
    
    Returns:
        Hash string in format "algorithm:hexdigest"
    """
    serialized = json.dumps(data, sort_keys=True, default=str)
    hasher = hashlib.new(algorithm)
    hasher.update(serialized.encode('utf-8'))
    return f"{algorithm}:{hasher.hexdigest()}"


class ReceiptGeneratingTool(BaseTool):
    """
    Base class for LangChain tools that automatically generate receipts.
    
    Extend this class and implement _execute() instead of _run().
    Receipts are automatically generated and stored.
    
    Example:
        class EmailTool(ReceiptGeneratingTool):
            name = "email_sender"
            description = "Send an email"
            
            def _execute(self, to: str, subject: str, body: str):
                send_email(to, subject, body)
                return {"status": "sent", "message_id": "msg_123"}
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._receipts: List[Dict[str, Any]] = []
    
    def _run(self, *args, **kwargs) -> Any:
        """
        Execute tool and generate receipt.
        DO NOT OVERRIDE - implement _execute() instead.
        """
        action_id = f"act_{uuid.uuid4().hex[:8]}"
        start_time = time.time()
        
        # Prepare input data
        input_data = {
            "args": args,
            "kwargs": kwargs
        }
        
        try:
            # Execute the tool
            output_data = self._execute(*args, **kwargs)
            status = "success"
            error_message = None
        except Exception as e:
            output_data = {"error": str(e)}
            status = "failed"
            error_message = str(e)
        
        latency_ms = int((time.time() - start_time) * 1000)
        
        # Generate receipt compliant with RECEIPT_SCHEMA.json
        receipt = {
            "action_id": action_id,
            "tool_name": self.name,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "status": status,
            "input_hash": hash_data(input_data),
            "output_hash": hash_data(output_data),
            "latency_ms": latency_ms
        }
        
        if error_message:
            receipt["error_message"] = error_message
        
        # Add custom metadata if returned by tool
        if isinstance(output_data, dict) and "metadata" in output_data:
            receipt["metadata"] = output_data["metadata"]
        
        # Store receipt for later retrieval
        self._receipts.append(receipt)
        
        if status == "failed":
            raise Exception(error_message)
        
        return output_data
    
    async def _arun(self, *args, **kwargs) -> Any:
        """Async version of _run"""
        return self._run(*args, **kwargs)
    
    def _execute(self, *args, **kwargs) -> Any:
        """
        Override this method with your tool logic.
        
        Args:
            *args, **kwargs: Tool-specific arguments
        
        Returns:
            Tool output (dict recommended for structured data)
        
        Raises:
            Exception: On tool failure
        """
        raise NotImplementedError("Subclasses must implement _execute()")
    
    def get_receipts(self) -> List[Dict[str, Any]]:
        """Get all receipts generated by this tool"""
        return self._receipts.copy()
    
    def clear_receipts(self) -> None:
        """Clear stored receipts"""
        self._receipts.clear()


def extract_receipts_from_agent_executor(
    agent_executor: AgentExecutor,
    result: Dict[str, Any],
    config: Optional[FailKitConfig] = None
) -> List[Dict[str, Any]]:
    """
    Extract action receipts from AgentExecutor intermediate steps.
    
    Args:
        agent_executor: The AgentExecutor instance
        result: Result from agent_executor.invoke()
        config: Optional configuration
    
    Returns:
        List of action receipts compliant with RECEIPT_SCHEMA.json
    """
    config = config or FailKitConfig()
    receipts = []
    
    # Extract from intermediate steps
    intermediate_steps = result.get("intermediate_steps", [])
    
    for i, (action, observation) in enumerate(intermediate_steps):
        action_id = f"act_{uuid.uuid4().hex[:8]}"
        
        # Extract tool info
        if isinstance(action, AgentAction):
            tool_name = action.tool
            tool_input = action.tool_input
        else:
            tool_name = f"unknown_tool_{i}"
            tool_input = {}
        
        # Prepare receipt
        receipt = {
            "action_id": action_id,
            "tool_name": tool_name,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "status": "success" if observation else "failed",
            "input_hash": hash_data(tool_input, config.hash_algorithm),
            "output_hash": hash_data({"result": observation}, config.hash_algorithm)
        }
        
        if config.include_metadata:
            receipt["metadata"] = {
                "observation": str(observation)[:200],  # Truncate long observations
                "log": getattr(action, "log", "")[:200] if hasattr(action, "log") else ""
            }
        
        receipts.append(receipt)
    
    # Also collect from ReceiptGeneratingTool instances
    for tool in agent_executor.tools:
        if isinstance(tool, ReceiptGeneratingTool):
            tool_receipts = tool.get_receipts()
            receipts.extend(tool_receipts)
            tool.clear_receipts()  # Clear for next invocation
    
    return receipts


def wrap_tool_with_receipts(tool: BaseTool) -> ReceiptGeneratingTool:
    """
    Wrap a legacy LangChain tool to generate receipts.
    
    Args:
        tool: Existing BaseTool instance
    
    Returns:
        ReceiptGeneratingTool that wraps the original tool
    """
    class WrappedTool(ReceiptGeneratingTool):
        name = tool.name
        description = tool.description
        
        def _execute(self, *args, **kwargs):
            if hasattr(tool, 'func'):
                return tool.func(*args, **kwargs)
            else:
                return tool._run(*args, **kwargs)
    
    return WrappedTool()


def create_fail_kit_endpoint(
    agent_executor: AgentExecutor,
    config: Optional[FailKitConfig] = None,
    custom_handler: Optional[Callable] = None
) -> APIRouter:
    """
    Create a FastAPI router with the /run endpoint for F.A.I.L. Kit audits.
    
    Args:
        agent_executor: LangChain AgentExecutor instance
        config: Optional FailKitConfig
        custom_handler: Optional custom handler function
    
    Returns:
        APIRouter with POST /run endpoint
    
    Example:
        app = FastAPI()
        app.include_router(
            create_fail_kit_endpoint(agent_executor),
            prefix="/eval"
        )
    """
    config = config or FailKitConfig()
    router = APIRouter()
    
    @router.post("/run")
    async def run_evaluation(request: FailKitRequest) -> Dict[str, Any]:
        """
        F.A.I.L. Kit evaluation endpoint
        
        Accepts a prompt and returns a structured response with actions and receipts.
        """
        # Extract prompt from request
        prompt = request.prompt
        if not prompt and request.inputs:
            prompt = request.inputs.get("user", "")
        
        if not prompt:
            raise HTTPException(status_code=400, detail="Missing prompt or inputs.user")
        
        try:
            # Run agent with custom handler if provided
            if custom_handler:
                result = await custom_handler(agent_executor, prompt, request.context or {})
            else:
                # Ensure intermediate steps are returned
                agent_executor.return_intermediate_steps = True
                result = await agent_executor.ainvoke({"input": prompt})
            
            # Extract output text
            output_text = result.get("output", "")
            if not output_text and isinstance(result, dict):
                # Try alternative keys
                output_text = result.get("result", result.get("response", ""))
            
            # Extract receipts
            receipts = extract_receipts_from_agent_executor(
                agent_executor,
                result,
                config
            )
            
            # Build response in F.A.I.L. Kit format
            response = {
                "outputs": {
                    "final_text": output_text,
                    "decision": "PASS"
                },
                "actions": receipts,
                "policy": {
                    "refuse": False,
                    "abstain": False,
                    "escalate": False,
                    "reasons": []
                }
            }
            
            # Check if we should escalate based on action failures
            failed_actions = [r for r in receipts if r.get("status") == "failed"]
            if failed_actions:
                response["policy"]["escalate"] = True
                response["policy"]["reasons"].append("tool_failure")
                response["outputs"]["decision"] = "FAIL"
            
            return response
        
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Agent execution failed: {str(e)}"
            )
    
    return router


def create_fail_kit_langgraph_endpoint(
    graph,
    config: Optional[FailKitConfig] = None
) -> APIRouter:
    """
    Create a FastAPI router for LangGraph agents.
    
    Args:
        graph: LangGraph CompiledStateGraph
        config: Optional FailKitConfig
    
    Returns:
        APIRouter with POST /run endpoint
    """
    config = config or FailKitConfig()
    router = APIRouter()
    
    @router.post("/run")
    async def run_evaluation(request: FailKitRequest) -> Dict[str, Any]:
        """F.A.I.L. Kit evaluation endpoint for LangGraph"""
        prompt = request.prompt or request.inputs.get("user", "") if request.inputs else ""
        
        if not prompt:
            raise HTTPException(status_code=400, detail="Missing prompt")
        
        try:
            # Run LangGraph
            result = await graph.ainvoke({"messages": [{"role": "user", "content": prompt}]})
            
            # Extract messages and actions from graph state
            messages = result.get("messages", [])
            output_text = messages[-1].content if messages else ""
            
            # Extract tool calls from messages
            receipts = []
            for msg in messages:
                if hasattr(msg, "additional_kwargs") and "tool_calls" in msg.additional_kwargs:
                    for tool_call in msg.additional_kwargs["tool_calls"]:
                        receipt = {
                            "action_id": f"act_{tool_call['id'][:8]}",
                            "tool_name": tool_call["function"]["name"],
                            "timestamp": datetime.utcnow().isoformat() + "Z",
                            "status": "success",
                            "input_hash": hash_data(tool_call["function"]["arguments"]),
                            "output_hash": hash_data({"result": "completed"})
                        }
                        receipts.append(receipt)
            
            return {
                "outputs": {
                    "final_text": output_text,
                    "decision": "PASS"
                },
                "actions": receipts,
                "policy": {
                    "refuse": False,
                    "abstain": False,
                    "escalate": False,
                    "reasons": []
                }
            }
        
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"LangGraph execution failed: {str(e)}"
            )
    
    return router


# Convenience exports
__all__ = [
    "ReceiptGeneratingTool",
    "FailKitConfig",
    "FailKitRequest",
    "create_fail_kit_endpoint",
    "create_fail_kit_langgraph_endpoint",
    "extract_receipts_from_agent_executor",
    "wrap_tool_with_receipts",
    "hash_data"
]
