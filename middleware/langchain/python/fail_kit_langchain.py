"""
F.A.I.L. Kit LangChain Adapter (Python)

Drop-in adapter for integrating LangChain agents with the F.A.I.L. Kit audit framework.
Automatically generates receipts from LangChain tool executions.
"""

import hashlib
import json
import time
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional, Union, Callable

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from langchain.agents import AgentExecutor
from langchain.tools import BaseTool
from langchain_core.agents import AgentAction, AgentFinish


class FailKitRequest(BaseModel):
    """Standard F.A.I.L. Kit request format"""
    prompt: Optional[str] = None
    inputs: Optional[Dict[str, Any]] = None
    context: Optional[Dict[str, Any]] = None


class FailKitConfig:
    """Configuration for F.A.I.L. Kit LangChain adapter"""
    
    def __init__(
        self,
        auto_receipts: bool = True,
        include_metadata: bool = True,
        track_latency: bool = True,
        hash_algorithm: str = "sha256"
    ):
        self.auto_receipts = auto_receipts
        self.include_metadata = include_metadata
        self.track_latency = track_latency
        self.hash_algorithm = hash_algorithm


def hash_data(data: Any, algorithm: str = "sha256") -> str:
    """
    Generate hash for receipt verification
    
    Args:
        data: Data to hash (will be JSON serialized)
        algorithm: Hash algorithm (default: sha256)
    
    Returns:
        Hash string in format "algorithm:hexdigest"
    """
    serialized = json.dumps(data, sort_keys=True, default=str)
    hasher = hashlib.new(algorithm)
    hasher.update(serialized.encode('utf-8'))
    return f"{algorithm}:{hasher.hexdigest()}"


class ReceiptGeneratingTool(BaseTool):
    """
    Base class for LangChain tools that automatically generate receipts.
    
    Extend this class and implement _execute() instead of _run().
    Receipts are automatically generated and stored.
    
    Example:
        class EmailTool(ReceiptGeneratingTool):
            name = "email_sender"
            description = "Send an email"
            
            def _execute(self, to: str, subject: str, body: str):
                send_email(to, subject, body)
                return {"status": "sent", "message_id": "msg_123"}
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._receipts: List[Dict[str, Any]] = []
    
    def _run(self, *args, **kwargs) -> Any:
        """
        Execute tool and generate receipt.
        DO NOT OVERRIDE - implement _execute() instead.
        """
        action_id = f"act_{uuid.uuid4().hex[:8]}"
        start_time = time.time()
        
        # Prepare input data
        input_data = {
            "args": args,
            "kwargs": kwargs
        }
        
        try:
            # Execute the tool
            output_data = self._execute(*args, **kwargs)
            status = "success"
            error_message = None
        except Exception as e:
            output_data = {"error": str(e)}
            status = "failed"
            error_message = str(e)
        
        latency_ms = int((time.time() - start_time) * 1000)
        
        # Generate receipt compliant with RECEIPT_SCHEMA.json
        receipt = {
            "action_id": action_id,
            "tool_name": self.name,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "status": status,
            "input_hash": hash_data(input_data),
            "output_hash": hash_data(output_data),
            "latency_ms": latency_ms
        }
        
        if error_message:
            receipt["error_message"] = error_message
        
        # Add custom metadata if returned by tool
        if isinstance(output_data, dict) and "metadata" in output_data:
            receipt["metadata"] = output_data["metadata"]
        
        # Store receipt for later retrieval
        self._receipts.append(receipt)
        
        if status == "failed":
            raise Exception(error_message)
        
        return output_data
    
    async def _arun(self, *args, **kwargs) -> Any:
        """Async version of _run"""
        return self._run(*args, **kwargs)
    
    def _execute(self, *args, **kwargs) -> Any:
        """
        Override this method with your tool logic.
        
        Args:
            *args, **kwargs: Tool-specific arguments
        
        Returns:
            Tool output (dict recommended for structured data)
        
        Raises:
            Exception: On tool failure
        """
        raise NotImplementedError("Subclasses must implement _execute()")
    
    def get_receipts(self) -> List[Dict[str, Any]]:
        """Get all receipts generated by this tool"""
        return self._receipts.copy()
    
    def clear_receipts(self) -> None:
        """Clear stored receipts"""
        self._receipts.clear()


def extract_receipts_from_agent_executor(
    agent_executor: AgentExecutor,
    result: Dict[str, Any],
    config: Optional[FailKitConfig] = None
) -> List[Dict[str, Any]]:
    """
    Extract action receipts from AgentExecutor intermediate steps.
    
    Args:
        agent_executor: The AgentExecutor instance
        result: Result from agent_executor.invoke()
        config: Optional configuration
    
    Returns:
        List of action receipts compliant with RECEIPT_SCHEMA.json
    """
    config = config or FailKitConfig()
    receipts = []
    
    # Extract from intermediate steps
    intermediate_steps = result.get("intermediate_steps", [])
    
    for i, (action, observation) in enumerate(intermediate_steps):
        action_id = f"act_{uuid.uuid4().hex[:8]}"
        
        # Extract tool info
        if isinstance(action, AgentAction):
            tool_name = action.tool
            tool_input = action.tool_input
        else:
            tool_name = f"unknown_tool_{i}"
            tool_input = {}
        
        # Prepare receipt
        receipt = {
            "action_id": action_id,
            "tool_name": tool_name,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "status": "success" if observation else "failed",
            "input_hash": hash_data(tool_input, config.hash_algorithm),
            "output_hash": hash_data({"result": observation}, config.hash_algorithm)
        }
        
        if config.include_metadata:
            receipt["metadata"] = {
                "observation": str(observation)[:200],  # Truncate long observations
                "log": getattr(action, "log", "")[:200] if hasattr(action, "log") else ""
            }
        
        receipts.append(receipt)
    
    # Also collect from ReceiptGeneratingTool instances
    for tool in agent_executor.tools:
        if isinstance(tool, ReceiptGeneratingTool):
            tool_receipts = tool.get_receipts()
            receipts.extend(tool_receipts)
            tool.clear_receipts()  # Clear for next invocation
    
    return receipts


def wrap_tool_with_receipts(tool: BaseTool) -> ReceiptGeneratingTool:
    """
    Wrap a legacy LangChain tool to generate receipts.
    
    Args:
        tool: Existing BaseTool instance
    
    Returns:
        ReceiptGeneratingTool that wraps the original tool
    """
    class WrappedTool(ReceiptGeneratingTool):
        name = tool.name
        description = tool.description
        
        def _execute(self, *args, **kwargs):
            if hasattr(tool, 'func'):
                return tool.func(*args, **kwargs)
            else:
                return tool._run(*args, **kwargs)
    
    return WrappedTool()


def create_fail_kit_endpoint(
    agent_executor: AgentExecutor,
    config: Optional[FailKitConfig] = None,
    custom_handler: Optional[Callable] = None
) -> APIRouter:
    """
    Create a FastAPI router with the /run endpoint for F.A.I.L. Kit audits.
    
    Args:
        agent_executor: LangChain AgentExecutor instance
        config: Optional FailKitConfig
        custom_handler: Optional custom handler function
    
    Returns:
        APIRouter with POST /run endpoint
    
    Example:
        app = FastAPI()
        app.include_router(
            create_fail_kit_endpoint(agent_executor),
            prefix="/eval"
        )
    """
    config = config or FailKitConfig()
    router = APIRouter()
    
    @router.post("/run")
    async def run_evaluation(request: FailKitRequest) -> Dict[str, Any]:
        """
        F.A.I.L. Kit evaluation endpoint
        
        Accepts a prompt and returns a structured response with actions and receipts.
        """
        # Extract prompt from request
        prompt = request.prompt
        if not prompt and request.inputs:
            prompt = request.inputs.get("user", "")
        
        if not prompt:
            raise HTTPException(status_code=400, detail="Missing prompt or inputs.user")
        
        try:
            # Run agent with custom handler if provided
            if custom_handler:
                result = await custom_handler(agent_executor, prompt, request.context or {})
            else:
                # Ensure intermediate steps are returned
                agent_executor.return_intermediate_steps = True
                result = await agent_executor.ainvoke({"input": prompt})
            
            # Extract output text
            output_text = result.get("output", "")
            if not output_text and isinstance(result, dict):
                # Try alternative keys
                output_text = result.get("result", result.get("response", ""))
            
            # Extract receipts
            receipts = extract_receipts_from_agent_executor(
                agent_executor,
                result,
                config
            )
            
            # Build response in F.A.I.L. Kit format
            response = {
                "outputs": {
                    "final_text": output_text,
                    "decision": "PASS"
                },
                "actions": receipts,
                "policy": {
                    "refuse": False,
                    "abstain": False,
                    "escalate": False,
                    "reasons": []
                }
            }
            
            # Check if we should escalate based on action failures
            failed_actions = [r for r in receipts if r.get("status") == "failed"]
            if failed_actions:
                response["policy"]["escalate"] = True
                response["policy"]["reasons"].append("tool_failure")
                response["outputs"]["decision"] = "FAIL"
            
            return response
        
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Agent execution failed: {str(e)}"
            )
    
    return router


def create_fail_kit_langgraph_endpoint(
    graph,
    config: Optional[FailKitConfig] = None
) -> APIRouter:
    """
    Create a FastAPI router for LangGraph agents.
    
    Args:
        graph: LangGraph CompiledStateGraph
        config: Optional FailKitConfig
    
    Returns:
        APIRouter with POST /run endpoint
    """
    config = config or FailKitConfig()
    router = APIRouter()
    
    @router.post("/run")
    async def run_evaluation(request: FailKitRequest) -> Dict[str, Any]:
        """F.A.I.L. Kit evaluation endpoint for LangGraph"""
        prompt = request.prompt or request.inputs.get("user", "") if request.inputs else ""
        
        if not prompt:
            raise HTTPException(status_code=400, detail="Missing prompt")
        
        try:
            # Run LangGraph
            result = await graph.ainvoke({"messages": [{"role": "user", "content": prompt}]})
            
            # Extract messages and actions from graph state
            messages = result.get("messages", [])
            output_text = messages[-1].content if messages else ""
            
            # Extract tool calls from messages
            receipts = []
            for msg in messages:
                if hasattr(msg, "additional_kwargs") and "tool_calls" in msg.additional_kwargs:
                    for tool_call in msg.additional_kwargs["tool_calls"]:
                        receipt = {
                            "action_id": f"act_{tool_call['id'][:8]}",
                            "tool_name": tool_call["function"]["name"],
                            "timestamp": datetime.utcnow().isoformat() + "Z",
                            "status": "success",
                            "input_hash": hash_data(tool_call["function"]["arguments"]),
                            "output_hash": hash_data({"result": "completed"})
                        }
                        receipts.append(receipt)
            
            return {
                "outputs": {
                    "final_text": output_text,
                    "decision": "PASS"
                },
                "actions": receipts,
                "policy": {
                    "refuse": False,
                    "abstain": False,
                    "escalate": False,
                    "reasons": []
                }
            }
        
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"LangGraph execution failed: {str(e)}"
            )
    
    return router


# ============================================
# NEW v1.6.0: Compliance Mappings
# ============================================

COMPLIANCE_MAPPINGS: Dict[str, Dict[str, List[str]]] = {
    "FK001": {
        "soc2": ["CC6.1", "CC7.2", "CC7.3"],
        "pci_dss": ["10.2.2", "10.3", "10.3.1"],
        "hipaa": ["164.312(b)", "164.308(a)(1)(ii)(D)"],
        "gdpr": ["Art. 30", "Art. 5(2)"],
    },
    "FK002": {
        "soc2": ["CC7.4", "CC7.5"],
        "pci_dss": ["6.5.5", "6.5.6"],
        "hipaa": ["164.308(a)(1)", "164.306(a)(2)"],
    },
    "FK003": {
        "soc2": ["CC6.7", "CC6.8", "CC6.1"],
        "pci_dss": ["3.4", "6.5.3", "8.2.1"],
        "hipaa": ["164.312(a)(1)", "164.312(e)(1)"],
        "gdpr": ["Art. 32", "Art. 25"],
    },
    "FK004": {
        "soc2": ["CC6.1", "CC7.1", "CC7.2"],
        "pci_dss": ["7.1", "7.2", "10.2.5"],
        "hipaa": ["164.312(d)", "164.308(a)(4)"],
    },
    "FK005": {
        "soc2": ["A1.2", "CC7.4"],
        "pci_dss": ["6.5.6", "12.10.1"],
    },
    "FK006": {
        "soc2": ["CC5.2", "CC7.2", "CC7.3"],
        "pci_dss": ["10.1", "10.2", "10.3.6"],
        "hipaa": ["164.312(b)", "164.308(a)(1)(ii)(D)"],
        "gdpr": ["Art. 30", "Art. 5(2)"],
    },
    "FK007": {
        "soc2": ["CC6.7", "CC6.8"],
        "pci_dss": ["2.3", "8.2.1", "8.2.3"],
        "hipaa": ["164.312(a)(1)", "164.312(d)"],
        "gdpr": ["Art. 32"],
    },
}


def get_compliance_badges(rule_id: str) -> List[str]:
    """Get compliance framework badges for a rule."""
    mapping = COMPLIANCE_MAPPINGS.get(rule_id, {})
    badges = []
    if mapping.get("soc2"):
        badges.append("SOC2")
    if mapping.get("pci_dss"):
        badges.append("PCI-DSS")
    if mapping.get("hipaa"):
        badges.append("HIPAA")
    if mapping.get("gdpr"):
        badges.append("GDPR")
    return badges


# ============================================
# NEW v1.6.0: Resilience Utilities
# ============================================

class RetryConfig:
    """Configuration for retry behavior."""
    
    def __init__(
        self,
        max_retries: int = 3,
        base_delay: float = 1.0,
        max_delay: float = 30.0,
        exponential_base: float = 2.0,
        jitter: bool = True
    ):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base
        self.jitter = jitter


async def with_retry(
    func: Callable,
    config: Optional[RetryConfig] = None,
    on_retry: Optional[Callable[[Exception, int], None]] = None
) -> Any:
    """
    Execute a function with retry logic.
    
    Args:
        func: Async function to execute
        config: Retry configuration
        on_retry: Callback for retry events
    
    Returns:
        Result of the function
    
    Example:
        result = await with_retry(
            lambda: llm.invoke(prompt),
            RetryConfig(max_retries=3)
        )
    """
    import asyncio
    import random
    
    cfg = config or RetryConfig()
    last_error = None
    
    for attempt in range(cfg.max_retries + 1):
        try:
            return await func()
        except Exception as e:
            last_error = e
            if attempt < cfg.max_retries:
                delay = min(
                    cfg.base_delay * (cfg.exponential_base ** attempt),
                    cfg.max_delay
                )
                if cfg.jitter:
                    delay *= (0.5 + random.random())
                
                if on_retry:
                    on_retry(e, attempt + 1)
                
                await asyncio.sleep(delay)
    
    raise last_error


def with_timeout(timeout_seconds: float):
    """
    Decorator to add timeout to async functions.
    
    Example:
        @with_timeout(30.0)
        async def call_llm(prompt: str):
            return await llm.invoke(prompt)
    """
    import asyncio
    from functools import wraps
    
    def decorator(func: Callable):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            return await asyncio.wait_for(
                func(*args, **kwargs),
                timeout=timeout_seconds
            )
        return wrapper
    return decorator


# ============================================
# NEW v1.6.0: Evidence Generation
# ============================================

class EvidencePackage:
    """Evidence package for audit exports."""
    
    def __init__(self, receipts: List[Dict[str, Any]], provenance: Dict[str, Any]):
        self.version = "1.0.0"
        self.generated_at = datetime.utcnow().isoformat() + "Z"
        self.receipts = receipts
        self.provenance = provenance
        self.signature = self._sign()
        self.compliance_mappings = self._map_compliance()
    
    def _sign(self) -> str:
        """Generate HMAC signature for evidence integrity."""
        import hmac
        data = json.dumps(self.receipts, sort_keys=True)
        return hmac.new(
            b"fail-kit-evidence",
            data.encode(),
            hashlib.sha256
        ).hexdigest()
    
    def _map_compliance(self) -> Dict[str, List[str]]:
        """Map receipts to compliance frameworks."""
        frameworks: Dict[str, List[str]] = {}
        for receipt in self.receipts:
            tool_name = receipt.get("tool_name", "")
            # Map tool types to FK rules
            if "payment" in tool_name.lower() or "charge" in tool_name.lower():
                for framework, controls in COMPLIANCE_MAPPINGS.get("FK001", {}).items():
                    if framework not in frameworks:
                        frameworks[framework] = []
                    frameworks[framework].extend(controls)
        return frameworks
    
    def to_dict(self) -> Dict[str, Any]:
        """Export as dictionary."""
        return {
            "version": self.version,
            "generated_at": self.generated_at,
            "receipts": self.receipts,
            "provenance": self.provenance,
            "signature": self.signature,
            "signature_algorithm": "HMAC-SHA256",
            "compliance_mappings": self.compliance_mappings,
        }
    
    def to_json(self) -> str:
        """Export as JSON string."""
        return json.dumps(self.to_dict(), indent=2)
    
    def to_csv(self) -> str:
        """Export receipts as CSV."""
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        headers = ["action_id", "tool_name", "timestamp", "status", "input_hash", "output_hash"]
        writer.writerow(headers)
        
        for receipt in self.receipts:
            writer.writerow([receipt.get(h, "") for h in headers])
        
        return output.getvalue()


def generate_evidence_package(
    receipts: List[Dict[str, Any]],
    git_hash: str = "unknown",
    git_branch: str = "unknown"
) -> EvidencePackage:
    """
    Generate an evidence package for audit export.
    
    Args:
        receipts: List of action receipts
        git_hash: Current git commit hash
        git_branch: Current git branch
    
    Returns:
        EvidencePackage with signed receipts
    """
    import platform
    
    provenance = {
        "git_hash": git_hash,
        "git_branch": git_branch,
        "platform": platform.system(),
        "python_version": platform.python_version(),
        "fail_kit_version": "1.6.0",
    }
    
    return EvidencePackage(receipts, provenance)


# ============================================
# NEW v1.6.0: Secret Detection
# ============================================

SECRET_PATTERNS = [
    (r"sk[-_]live[-_][a-zA-Z0-9]{20,}", "stripe_secret_key"),
    (r"sk[-_]test[-_][a-zA-Z0-9]{20,}", "stripe_test_key"),
    (r"AKIA[A-Z0-9]{16}", "aws_access_key"),
    (r"sk-[a-zA-Z0-9]{32,}", "openai_api_key"),
    (r"ghp_[a-zA-Z0-9]{36}", "github_pat"),
]


def detect_secrets(text: str) -> List[Dict[str, str]]:
    """
    Detect potential secrets in text.
    
    Args:
        text: Text to scan for secrets
    
    Returns:
        List of detected secrets with type and masked value
    """
    import re
    
    findings = []
    for pattern, secret_type in SECRET_PATTERNS:
        matches = re.findall(pattern, text)
        for match in matches:
            findings.append({
                "type": secret_type,
                "masked": match[:4] + "..." + match[-4:] if len(match) > 8 else "***",
                "severity": "critical",
            })
    
    return findings


# Convenience exports
__all__ = [
    "ReceiptGeneratingTool",
    "FailKitConfig",
    "FailKitRequest",
    "create_fail_kit_endpoint",
    "create_fail_kit_langgraph_endpoint",
    "extract_receipts_from_agent_executor",
    "wrap_tool_with_receipts",
    "hash_data",
    # v1.6.0 additions
    "COMPLIANCE_MAPPINGS",
    "get_compliance_badges",
    "RetryConfig",
    "with_retry",
    "with_timeout",
    "EvidencePackage",
    "generate_evidence_package",
    "detect_secrets",
]
