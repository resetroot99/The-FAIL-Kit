/**
 * F.A.I.L. Kit CI/CD Integration
 *
 * Native integration with GitHub Actions and GitLab CI.
 * Posts audit summaries to PRs/MRs and blocks merges on critical failures.
 */

const { postGitHubComment, getGitHubContext, createGitHubCheckRun } = require('./github-commenter');
const { postGitLabComment, getGitLabContext, updateGitLabMergeability } = require('./gitlab-commenter');

/**
 * Detect CI environment
 */
function detectCIEnvironment() {
  if (process.env.GITHUB_ACTIONS === 'true') {
    return 'github';
  }
  if (process.env.GITLAB_CI === 'true') {
    return 'gitlab';
  }
  if (process.env.JENKINS_URL) {
    return 'jenkins';
  }
  if (process.env.CIRCLECI === 'true') {
    return 'circleci';
  }
  if (process.env.TRAVIS === 'true') {
    return 'travis';
  }
  if (process.env.BUILDKITE === 'true') {
    return 'buildkite';
  }
  if (process.env.CI === 'true') {
    return 'generic';
  }
  return null;
}

/**
 * Generate PR/MR comment content from audit results
 */
function generateCommentContent(results, options = {}) {
  const { passed, failed, total, results: testResults } = results;
  const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;
  
  // Categorize failures
  const failures = testResults.filter(r => !r.pa  const criticalFailures = failures.filter(f => 
    f.case.includes('CONTRACT_0003') || 
    f.case.includes('CONTRACT_02') ||
    f.case.includes('AGENT_0008') ||
    f.case.includes('AUTO_receipt') ||
    f.case.includes('FK010') || // Phantom Completion
    f.case.includes('FK014') || // Hallucinated Tool
    f.case.includes('FK039') || // Silent Failure Cascade
    f.case.includes('FK040')    // Receipt Tampering
  );
  const highFailures = failures.filter(f =>
    f.case.includes('REFUSE') ||
    f.case.includes('CONTRACT_0004') ||
    f.case.startsWith('ADV_') ||
    f.case.includes('FK025') || // Confidence Without Evidence
    f.case.includes('FK019')    // Retrieval Gap
  );
  let statusEmoji, statusText, decision;
  if (criticalFailures.length > 0) {
    statusEmoji = 'ðŸš«';
    statusText = 'BLOCK';
    decision = 'block';
  } else if (highFailures.length > 0 || failed >= 5) {
    statusEmoji = 'âš ï¸';
    statusText = 'NEEDS REVIEW';
    decision = 'review';
  } else if (parseFloat(passRate) >= 95) {
    statusEmoji = 'âœ…';
    statusText = 'PASS';
    decision = 'pass';
  } else {
    statusEmoji = 'âš ï¸';
    statusText = 'NEEDS REVIEW';
    decision = 'review';
  }
  
  let comment = `## ${statusEmoji} F.A.I.L. Kit Audit: ${statusText}\n\n`;
  
  // Summary table
  comment += `| Metric | Value |\n`;
  comment += `|--------|-------|\n`;
  comment += `| **Pass Rate** | ${passRate}% (${passed}/${total}) |\n`;
  comment += `| **Critical Issues** | ${criticalFailures.length} |\n`;
  comment += `| **High Severity** | ${highFailures.length} |\n`;
  comment += `| **Duration** | ${((results.duration_ms || 0) / 1000).toFixed(2)}s |\n\n`;
  
  // Decision block
  if (decision === 'block') {
    comment += `> **ðŸš« Merge Blocked**\n`;
    comment += `> ${criticalFailures.length} critical forensic gap(s) detected. Fix before merging.\n\n`;
  } else if (decision === 'review') {
    comment += `> **âš ï¸ Manual Review Required**\n`;
    comment += `> Please review the failures below before approving.\n\n`;
  } else {
    comment += `> **âœ… Ready to Ship**\n`;
    comment += `> All critical checks passed. Safe to merge.\n\n`;
  }
  
  // Failures section
  if (failures.length > 0) {
    comment += `### Failed Tests\n\n`;
    comment += `<details>\n`;
    comment += `<summary>View ${failures.length} failure(s)</summary>\n\n`;
    comment += `| Test | Category | Reason |\n`;
    comment += `|------|----------|--------|\n`;
    
    for (const failure of failures.slice(0, 20)) {
      const category = failure.case.split('_')[0];
      const reason = (failure.reason || failure.error || 'Failed').substring(0, 50);
      const severity = criticalFailures.includes(failure) ? 'ðŸ”´' : 
                       highFailures.includes(failure) ? 'ðŸŸ ' : 'ðŸŸ¡';
      comment += `| ${severity} \`${failure.case}\` | ${category} | ${reason}${reason.length >= 50 ? '...' : ''} |\n`;
    }
    
    if (failures.length > 20) {
      comment += `\n*...and ${failures.length - 20} more*\n`;
    }
    
    comment += `\n</details>\n\n`;
  }
  
  // Root causes
  const rootCauses = extractRootCauses(failures);
  if (rootCauses.length > 0) {
    comment += `### Top Issues\n\n`;
    for (let i = 0; i < Math.min(3, rootCauses.length); i++) {
      const cause = rootCauses[i];
      comment += `${i + 1}. **${cause.cause}** (${cause.count} test${cause.count > 1 ? 's' : ''})\n`;
    }
    comment += '\n';
  }
  
  // Footer
  comment += `---\n`;
  comment += `<sub>Generated by [F.A.I.L. Kit](https://github.com/resetroot99/The-FAIL-Kit) v${require('../../package.json').version} â€¢ `;
  comment += `[View Full Report](${options.reportUrl || '#'}) â€¢ `;
  comment += `Commit: \`${options.commitSha?.substring(0, 7) || 'unknown'}\`</sub>\n`;
  
  return { comment, decision, criticalCount: criticalFailures.length, highCount: highFailures.length };
}

/**
 * Extract root causes from failures
 */
function extractRootCauses(failures) {
  const causes = {};
  
  for (const failure of failures) {
    let cause;
    if (failure.case.includes('CONTRACT_0003') || failure.case.includes('receipt')) {
      cause = 'Missing action receipts';
    } else if (failure.case.includes('REFUSE') || failure.case.includes('policy')) {
      cause = 'Policy gate violations';
    } else if (failure.case.includes('citation') || failure.case.startsWith('GROUND_')) {
      cause = 'Missing evidence/citations';
    } else if (failure.case.startsWith('SHIFT_')) {
      cause = 'Tool execution errors';
    } else if (failure.case.startsWith('ADV_')) {
      cause = 'Adversarial vulnerability';
    } else {
      cause = 'Validation failures';
    }
    
    causes[cause] = (causes[cause] || 0) + 1;
  }
  
  return Object.entries(causes)
    .map(([cause, count]) => ({ cause, count }))
    .sort((a, b) => b.count - a.count);
}

/**
 * Post audit results to PR/MR
 */
async function postAuditResults(results, options = {}) {
  const ci = detectCIEnvironment();
  
  if (!ci) {
    console.log('Not running in CI environment, skipping PR comment');
    return { posted: false, reason: 'Not in CI' };
  }
  
  const { comment, decision, criticalCount, highCount } = generateCommentContent(results, options);
  
  try {
    if (ci === 'github') {
      const context = getGitHubContext();
      if (!context.pullRequest) {
        console.log('Not a pull request, skipping comment');
        return { posted: false, reason: 'Not a PR' };
      }
      
      await postGitHubComment(comment, context);
      
      // Create check run for merge blocking
      if (options.createCheck !== false) {
        await createGitHubCheckRun({
          name: 'F.A.I.L. Kit Audit',
          conclusion: decision === 'block' ? 'failure' : decision === 'review' ? 'neutral' : 'success',
          summary: `${decision === 'block' ? 'Blocked' : decision === 'review' ? 'Needs Review' : 'Passed'}: ${criticalCount} critical, ${highCount} high severity issues`,
          context,
        });
      }
      
      return { 
        posted: true, 
        platform: 'github', 
        decision,
        prNumber: context.pullRequest.number,
      };
    }
    
    if (ci === 'gitlab') {
      const context = getGitLabContext();
      if (!context.mergeRequest) {
        console.log('Not a merge request, skipping comment');
        return { posted: false, reason: 'Not an MR' };
      }
      
      await postGitLabComment(comment, context);
      
      // Update merge request approval status
      if (options.updateMergeability !== false && decision === 'block') {
        await updateGitLabMergeability(context, false, 'F.A.I.L. Kit: Critical forensic gaps detected');
      }
      
      return { 
        posted: true, 
        platform: 'gitlab', 
        decision,
        mrIid: context.mergeRequest.iid,
      };
    }
    
    // Generic CI - just output to console
    console.log('\n' + '='.repeat(60));
    console.log('F.A.I.L. Kit Audit Summary');
    console.log('='.repeat(60));
    console.log(`Decision: ${decision.toUpperCase()}`);
    console.log(`Pass Rate: ${results.passed}/${results.total}`);
    console.log(`Critical: ${criticalCount}, High: ${highCount}`);
    console.log('='.repeat(60) + '\n');
    
    return { posted: false, platform: ci, decision, reason: 'Output to console only' };
    
  } catch (error) {
    console.error('Failed to post audit results:', error.message);
    return { posted: false, error: error.message };
  }
}

/**
 * Generate CI-friendly exit code based on results
 */
function getExitCode(results, options = {}) {
  const { comment, decision } = generateCommentContent(results, options);
  
  if (options.strict) {
    // Strict mode: fail on any failure
    return results.failed > 0 ? 1 : 0;
  }
  
  if (options.blockOnCritical !== false) {
    // Default: fail only on critical issues
    return decision === 'block' ? 1 : 0;
  }
  
  // Lenient: never fail the build
  return 0;
}

/**
 * Generate badge URL for README
 */
function generateBadgeUrl(results) {
  const passRate = results.total > 0 ? ((results.passed / results.total) * 100).toFixed(0) : 0;
  const color = passRate >= 95 ? 'brightgreen' : passRate >= 80 ? 'yellow' : 'red';
  return `https://img.shields.io/badge/F.A.I.L.%20Kit-${passRate}%25-${color}`;
}

module.exports = {
  detectCIEnvironment,
  generateCommentContent,
  postAuditResults,
  getExitCode,
  generateBadgeUrl,
  extractRootCauses,
};
